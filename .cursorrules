# Trae/Cursor Rules for MPV-Electron

This file is automatically generated from the rules in `.cursor/rules/`.

## ğŸ¯ Core Principles

**Force Rule: Plan First, Then Execute**
For any code modification request, you must first provide a detailed implementation plan. Only when the user explicitly says "start implementation", "execute", "implement", "go", etc., should you modify the code.

**Force Rule: Real-time Architecture Documentation Update**
The architecture document (`docs/ARCHITECTURE.md`) must be updated in real-time with code/architecture changes in the same round of work. It is forbidden to wait for the user to remind you. Any changes involving interfaces, data structures, IPC, layering, state machines, file paths, etc., must be updated in the corresponding chapters and charts of the architecture document at the same time as the code modification is completed.

## ğŸ“‹ Agent Workflow (Based on Andrew Ng's Pattern)

### Core Design Principles
1. **Reflection**: Reflect on your output, check for errors or areas for improvement.
2. **Planning**: Break down complex tasks into executable subtasks.
3. **Tool Use**: Be clear about when to use tools and how to choose the most appropriate one.
4. **Action**: Execute tasks according to the plan.
5. **Review**: Review the execution results to ensure quality.

### Standard Workflow

#### Phase 1: Understand & Reflect
1. **Read user requirements carefully**: Identify explicit/implicit requirements and constraints.
2. **Understand business goals and context**: What problem does this solve? Relationship with existing features? User scenarios?
3. **Reflect on understanding**: Do I fully understand? Any ambiguities? Need clarification?
4. **Identify relevant files and modules**: Use `codebase_search` and `grep`.

#### Phase 2: Analyze & Plan
1. **Search existing implementations (Must prioritize)**:
   - Use `codebase_search` and `grep`.
   - **Avoid duplicate implementation**.
   - **Identify reusable code modules**.
   - **CRITICAL: If designing new interfaces/types, must search existing callers first to understand actual data formats.**
2. **Analyze existing data formats**:
   - IPC: Search how renderer sends data (e.g., `grep "window.electronAPI.send.*channel-name"`).
   - Function calls: Search existing callers for parameter formats.
   - Types: Check existing definitions.
   - **Ensure compatibility with existing callers**.
3. **Analyze architecture and dependencies**.
4. **Identify unused content**.
5. **Select tools**.

#### Phase 3: Plan & Reflect
**Must include**:
1. **Requirement Analysis**.
2. **Existing Implementation Analysis (CRITICAL)**: Data formats, call patterns, compatibility check.
3. **Impact Scope**: Files to modify, new files, doc updates.
4. **Implementation Scheme**: Data flow, component design, IPC design (must match existing format), state management.
5. **Implementation Steps**: Detailed steps with tools. **Verify compatibility**.
6. **Risk Assessment**: Electron boundaries, HDR/EDR, performance, backward compatibility, type safety.
7. **Test Plan**: Functional points, edge cases, compatibility tests.
8. **Reflection Check**: Is the plan complete? Existing implementation analyzed? Compatible?

#### Phase 4: Wait
Ensure user agreement before code modification.

#### Phase 5: Implement & Review
1. **Execute subtasks**: Follow the plan strictly.
2. **Tool usage**: Batch operations.
3. **Code quality check**: Style consistency, existing patterns, type safety.
4. **Real-time review**: Check for errors after each file.
5. **Documentation update**: **Update `docs/ARCHITECTURE.md` immediately**.
6. **Final review**.

## ğŸ—ï¸ Architecture Rules

**Important**: Detailed project architecture is in `docs/ARCHITECTURE.md`.

**Force Rule**: Architecture documentation must be updated in real-time, not depending on user reminders.

### Scenarios requiring updates
1. **Interface changes**: Update Chapter 3 (Core Interfaces & Data Structures).
2. **Data structure changes**: Update Chapter 4 (Data Structure Definitions).
3. **IPC communication changes**: Update Chapter 5 (IPC Communication Design).
4. **File changes**: Update Section 12.2 (File Path Reference).
5. **Architecture changes**: Update Chapter 2 (Overall Layered Architecture).

### Update Check
In the **same round of work** as code modification:
- [ ] Determine if the change affects architecture docs.
- [ ] If yes, update `docs/ARCHITECTURE.md` immediately.
- [ ] Use the update checklist (Section 13.3).
- [ ] Update "Last Updated" date.
- [ ] Ensure docs match code.

## ğŸ’» Code Standards

### File Organization
- **One file per class/interface**.
- **Unified entry file**: Infrastructure modules should provide `index.ts`.
- **Type classification**: Related types in `types.ts`.
- **Lazy loading**: Encapsulate native binding loading.

### TypeScript
- Strict mode, type safety.
- Use interfaces for contracts.
- Avoid `any`, use `unknown` or specific types.

### Vue 3
- Composition API.
- TypeScript support.
- Single responsibility components.
- Use composables.

### IPC Communication Pattern
```typescript
// renderer -> preload -> main
// 1. renderer calls window.electronAPI.xxx()
// 2. preload exposes API via contextBridge
// 3. main handles via ipcMain.on()
```

### Error Handling
- Promise try-catch.
- IPC error callbacks.
- Handle exceptions in native module calls.

### Prohibited Behaviors
- âŒ Modifying code without planning.
- âŒ Ignoring Electron process boundaries.
- âŒ Breaking HDR rendering logic.
- âŒ No test plan.
- âŒ Skipping error handling.
- âŒ Breaking type safety.
- âŒ **Creating duplicate documentation**.
- âŒ **Creating duplicate code modules**.
- âŒ **Keeping unused code/docs/scripts**.
- âŒ **Not updating architecture docs after changes**.

## ğŸ”„ Code Reuse Rules

**Force Rule**: Never create duplicate code modules, functions, or utility classes. Reuse existing code.

### Pre-creation Check
1. **Search existing code**: Use `codebase_search` or `grep`.
2. **Identify duplicate functionality**: Reuse or extend. Refactor if needed.
3. **Reuse principles**: Parameterize, combine, generic utilities.

### Refactoring Principles
1. **Extract common parts**.
2. **Progressive refactoring**.
3. **Maintain architecture consistency**.

## ğŸ§¹ Code Cleanup Rules

**Force Rule**: Regularly identify and delete unused code, documentation, scripts, and configurations.

### Cleanup Content
1. **Unused Code**: Unused functions/classes, commented code, obsolete implementations, debug code.
2. **Unused Docs**: Resolved issues, obsolete config, duplicates, temporary notes.
3. **Unused Scripts**: Broken, replaced, or information-only scripts.
4. **Unused Config**: Unused npm scripts, dependencies.

### Cleanup Process
1. **Identify**: Grep for references.
2. **Confirm**: Check git history.
3. **Safe Delete**: Backup/commit, delete, update references.
4. **Check**: Verify no broken dependencies.

## ğŸ“„ Documentation Rules

**Force Rule**: Never generate duplicate documentation. Update existing documentation.

### Pre-creation Check
1. **Search existing docs**: Use `glob_file_search` or `grep`.
2. **Identify duplicate content**: Merge into existing.
3. **Naming**: Clear, descriptive.

### Update Process
1. **If creating**: Search first. If exists, update. If not, create.
2. **If duplicate found**: Merge, update date, delete duplicate.
