# MPV Player - Cursor AI 工作流规则

> **版本**: 1.3.0  
> **最后更新**: 2026-01-25  
> **维护**: 如有问题请更新此文件

## 🎯 核心原则：先规划，再执行

**强制规则：对于任何代码修改请求，必须先提供详细的实现计划，只有在用户明确说"开始实现"、"执行"、"implement"、"go"等指令时，才进行代码修改。**

## 📋 标准工作流程

### 阶段 1：需求理解（Understand）
- 仔细阅读用户需求
- 理解业务目标和上下文
- 识别相关文件和模块

### 阶段 2：代码分析（Analyze）
- 使用 @文件名 引用相关代码
- **搜索现有代码，避免重复实现**
- **识别无用代码、文档、脚本**
- 分析现有架构和模式
- 识别依赖关系和影响范围
- 识别可复用的代码模块

### 阶段 3：规划制定（Plan）
必须包含以下内容：
1. **文件清单**：列出所有需要创建/修改的文件
2. **架构设计**：说明如何融入现有架构
3. **实现步骤**：分步骤详细说明
4. **风险评估**：潜在问题和注意事项
5. **测试方案**：如何验证功能

### 阶段 4：等待确认（Wait）
- 明确说明"等待确认"
- 不要直接修改代码
- 可以回答关于计划的提问

### 阶段 5：执行实现（Implement）
- 只有在用户明确确认后才执行
- 严格按照计划实施
- 保持代码风格一致

## 🏗️ 项目架构理解

### Electron 三层架构
```
main/          → 主进程（播放器核心逻辑）
preload/       → 预加载脚本（IPC 桥接，类型安全）
renderer/      → 渲染进程（Vue 3 UI）
native/        → 原生模块（libmpv 绑定，C++/Objective-C）
```

### 关键模块职责
- `corePlayer.ts`: 播放器核心，状态管理，窗口管理
- `libmpv.ts`: MPV 控制器封装，命令执行
- `renderManager.ts`: 渲染循环，HDR/EDR 管理
- `ipcHandlers.ts`: IPC 消息处理，文件选择，播放控制
- `playerState.ts`: 状态机，播放阶段管理
- `videoPlayerApp.ts`: 应用级逻辑，播放列表管理
- `timeline.ts`: 时间轴更新，进度同步

### 重要特性
- macOS HDR (EDR/PQ) 支持
- gpu-next backend (libplacebo)
- Dolby Vision 支持
- 原生渲染（CAOpenGLLayer）
- 双窗口模式（视频窗口 + 控制窗口）

## 💻 代码规范

### TypeScript
- 严格模式，类型安全
- 使用接口定义契约
- 避免 any，使用 unknown 或具体类型

### Vue 3
- Composition API
- TypeScript 支持
- 组件职责单一
- 使用 composables 复用逻辑

### IPC 通信模式
```typescript
// renderer → preload → main
// 1. renderer 调用 window.electronAPI.xxx()
// 2. preload 通过 contextBridge 暴露 API
// 3. main 通过 ipcMain.on() 处理
```

### 错误处理
- Promise 使用 try-catch
- IPC 通信要有错误回调
- 原生模块调用要处理异常

## 🔄 规划模板结构

每次规划必须包含：

### 1. 需求分析
- 用户目标是什么
- 涉及哪些功能模块

### 2. 影响范围
- 需要修改的文件（main/preload/renderer/native）
- 是否需要新增文件
- 对现有功能的影响

### 3. 实现方案
- 数据流设计
- 组件/模块设计
- IPC 通信设计（如果涉及）
- 状态管理设计

### 4. 实现步骤
- 步骤 1：xxx
- 步骤 2：xxx
- ...

### 5. 注意事项
- Electron 进程边界
- HDR/EDR 相关影响
- 性能考虑
- 内存管理

### 6. 测试方案
- 功能测试点
- 边界情况
- 建议的测试命令

## ⚠️ 特殊注意事项

### HDR/EDR 相关
- 涉及渲染的修改要考虑 HDR 影响
- 检查 renderManager.ts 和 native/mpv_render_gl.mm
- 确保颜色空间和 tone mapping 正确

### 进程边界
- main 和 renderer 不能直接通信
- 必须通过 preload 桥接
- 注意数据序列化（不能传递函数、类实例）

### 原生模块
- 注意内存管理
- C++/Objective-C 桥接要小心
- 错误处理要完善

### 状态管理
- 使用 PlayerStateMachine 管理播放状态
- 状态变化要触发相应事件
- 避免状态不一致

## 🚫 禁止行为

- ❌ 未经规划直接修改代码
- ❌ 忽略 Electron 进程边界
- ❌ 破坏现有的 HDR 渲染逻辑
- ❌ 不提供测试方案
- ❌ 跳过错误处理
- ❌ 破坏类型安全
- ❌ **创建重复文档**（必须先搜索现有文档，更新而不是创建）
- ❌ **创建重复代码模块**（必须先搜索现有代码，复用或扩展而不是创建）
- ❌ **保留无用代码/文档/脚本**（定期清理，保持代码库整洁）

## ✅ 推荐行为

- ✅ 先分析再规划
- ✅ 分步骤详细说明
- ✅ 考虑架构影响
- ✅ 提供测试建议
- ✅ 保持代码风格一致
- ✅ 遵循现有模式
- ✅ **创建文档前先搜索现有文档**
- ✅ **更新现有文档而不是创建新文档**
- ✅ **创建代码前先搜索现有代码**
- ✅ **复用或扩展现有代码而不是创建新代码**
- ✅ **定期清理无用代码、文档、脚本**
- ✅ **重构后删除旧实现**

## 📚 参考文档

- 规划模板：`docs/workflow/PLANNING_TEMPLATE.md`
- 提示词模板：`docs/workflow/PROMPT_TEMPLATES.md`
- 工作流检查清单：`docs/workflow/WORKFLOW_CHECKLIST.md`
- 更新日志：`docs/workflow/CHANGELOG.md`
- **架构文档**：`docs/ARCHITECTURE.md`（**必须保持实时更新**）

## 📄 文档管理规则

**强制规则：任何时候都不能生成重复文档。如果发现已有相关文档，必须更新现有文档，而不是创建新文档。**

## 💻 代码模块管理规则

**强制规则：任何时候都不能创建重复的代码模块、函数或工具类。如果发现已有相关功能，必须复用现有代码，而不是创建新代码。**

### 代码创建前检查

在创建任何代码模块、函数或工具类之前，必须：

1. **搜索现有代码**：
   - 使用 `codebase_search` 或 `grep` 搜索相关功能的实现
   - 检查 `src/` 目录下的所有子目录
   - 检查是否有相似功能的函数、类或模块
   - 检查工具函数、工具类、辅助模块

2. **识别重复功能**：
   - 如果发现功能相似的代码，必须复用现有代码
   - 如果现有代码需要扩展，优先扩展而不是创建新的
   - 如果现有代码设计不合理，先重构再复用

3. **代码复用原则**：
   - 优先使用现有函数/类
   - 通过参数扩展功能，而不是复制代码
   - 创建通用的工具函数，避免重复实现
   - 使用组合而不是重复

### 代码模块更新流程

1. **发现需要创建代码时**：
   - 先搜索是否已有相关实现
   - 如果有，复用或扩展现有代码
   - 如果没有，创建新代码，但要考虑通用性

2. **发现重复代码时**：
   - 识别最佳实现（最通用、最清晰、最符合架构）
   - 将其他地方的调用迁移到最佳实现
   - 删除重复代码
   - 更新相关引用

3. **代码模块检查清单**：
   - [ ] 已搜索现有代码
   - [ ] 已识别可复用的代码
   - [ ] 已复用或扩展现有代码
   - [ ] 已删除重复代码
   - [ ] 已更新所有引用
   - [ ] 代码符合架构设计

### 常见重复场景

1. **工具函数重复**：
   - 文件路径处理（`path.join`, `path.basename` 等）
   - 时间格式化
   - 数据验证
   - 错误处理包装

2. **类型定义重复**：
   - 接口定义
   - 枚举类型
   - 类型别名

3. **业务逻辑重复**：
   - 状态管理逻辑
   - 数据处理逻辑
   - 事件处理逻辑

### 示例

**错误做法**：
```typescript
// 文件1: utils/formatTime.ts
export function formatTime(seconds: number): string { ... }

// 文件2: helpers/timeHelper.ts  
export function formatDuration(seconds: number): string { ... } // 重复实现

// 文件3: components/TimeDisplay.ts
function formatSeconds(seconds: number): string { ... } // 又重复实现
```

**正确做法**：
```typescript
// 统一工具文件: utils/timeUtils.ts
export function formatTime(seconds: number): string { ... }

// 其他地方都导入使用
import { formatTime } from '@/utils/timeUtils'
```

### 代码重构原则

当发现重复代码时：

1. **提取公共部分**：
   - 创建通用函数/类
   - 将差异部分作为参数
   - 保持向后兼容

2. **渐进式重构**：
   - 先创建通用实现
   - 逐步迁移调用方
   - 最后删除旧代码

3. **保持架构一致性**：
   - 遵循项目架构（Domain/Application/Infrastructure）
   - 保持代码风格一致
   - 更新相关文档

### 文档创建前检查

在创建任何文档之前，必须：

1. **搜索现有文档**：
   - 使用 `glob_file_search` 或 `grep` 搜索相关主题的文档
   - 检查 `docs/` 目录下的所有子目录
   - 检查文件名是否相似（如 `TEST.md`, `TESTING.md`, `HOW_TO_TEST.md` 等）

2. **识别重复内容**：
   - 如果发现主题相似的文档，必须合并内容
   - 更新现有文档而不是创建新文档
   - 删除重复或过时的文档

3. **文档命名规范**：
   - 使用清晰、描述性的文件名
   - 避免创建多个功能相似的文档
   - 优先更新现有文档

### 文档更新流程

1. **发现需要创建文档时**：
   - 先搜索是否已有相关文档
   - 如果有，更新现有文档
   - 如果没有，创建新文档

2. **发现重复文档时**：
   - 合并内容到最合适的文档
   - 更新文档的"最后更新"日期
   - 删除重复的文档

3. **文档更新检查清单**：
   - [ ] 已搜索现有文档
   - [ ] 已合并重复内容
   - [ ] 已更新"最后更新"日期
   - [ ] 已删除重复文档
   - [ ] 文档内容完整且准确

### 示例

**错误做法**：
- 创建 `docs/development/TEST.md`
- 创建 `docs/development/TESTING.md`
- 创建 `docs/development/HOW_TO_TEST.md`
- 创建 `docs/development/QUICK_TEST.md`

**正确做法**：
- 搜索发现已有 `docs/development/TESTING_GUIDE.md`
- 更新 `TESTING_GUIDE.md` 添加新内容
- 删除其他重复文档

## 🧹 代码清理规则

**强制规则：定期识别并删除无用的代码、文档、脚本和配置文件，保持代码库整洁。**

### 需要清理的内容

1. **无用代码**：
   - 未使用的函数、类、模块
   - 注释掉的代码（除非有明确原因保留）
   - 过时的实现（已被新实现替代）
   - 调试代码（console.log、临时变量等）

2. **无用文档**：
   - 已解决的问题相关文档
   - 过时的配置说明
   - 重复的文档（已合并到其他文档）
   - 临时记录文档

3. **无用脚本**：
   - 无法正常工作的脚本
   - 已被替代的脚本
   - 仅包含提示信息的脚本（应合并到文档）

4. **无用配置**：
   - 未使用的 npm 脚本
   - 未使用的依赖（需要确认）
   - 过时的配置文件

### 清理流程

1. **识别无用内容**：
   - 使用 `grep` 搜索引用
   - 检查 `package.json` 中的脚本是否被使用
   - 检查导入/导出是否被引用
   - 检查文档是否还有价值

2. **确认无用性**：
   - 搜索整个代码库确认无引用
   - 检查 git 历史确认是否最近使用
   - 确认是否有计划使用

3. **安全删除**：
   - 先备份或提交到 git（如果重要）
   - 删除无用文件
   - 更新相关引用
   - 更新文档索引

4. **清理检查清单**：
   - [ ] 已搜索所有引用
   - [ ] 已确认无其他依赖
   - [ ] 已更新相关文档
   - [ ] 已更新 package.json（如果是脚本）
   - [ ] 已提交到 git

### 清理时机

1. **重构时**：
   - 重构后删除旧实现
   - 合并重复代码后删除重复部分

2. **功能完成后**：
   - 删除临时测试代码
   - 删除调试代码
   - 清理临时文档

3. **定期清理**：
   - 在规划阶段识别无用内容
   - 在代码审查时检查
   - 在文档更新时清理过时文档

### 清理原则

1. **谨慎删除**：
   - 不确定时先注释或标记为废弃
   - 重要代码先备份
   - 保留 git 历史以便恢复

2. **渐进式清理**：
   - 先标记为废弃
   - 逐步迁移引用
   - 最后删除

3. **保持一致性**：
   - 删除代码时同步更新文档
   - 删除文档时同步更新索引
   - 删除脚本时同步更新 package.json

### 示例

**识别无用脚本**：
```bash
# 检查脚本是否被引用
grep -r "test_domain.js" .
# 检查 package.json 中是否使用
grep "test_domain" package.json
# 如果都没有引用，可以删除
```

**识别无用代码**：
```typescript
// 搜索函数引用
grep -r "oldFunction" src/
// 如果没有引用，可以删除
```

**识别无用文档**：
```bash
# 检查文档是否被引用
grep -r "OLD_DOC.md" docs/
# 如果文档内容已合并到其他文档，可以删除
```

## 🔄 架构文档更新规则

**重要：任何架构相关的代码变更都必须同步更新 `docs/ARCHITECTURE.md`**

### 必须更新的场景

1. **接口变更**（新增/修改/删除）
   - 更新第3章（核心接口与数据结构）
   - 更新相关使用示例
   - 更新接口注释

2. **数据结构变更**
   - 更新第4章（数据结构定义）
   - 更新相关接口说明

3. **IPC通信变更**
   - 更新第5章（IPC通信设计）
   - 更新IPC消息通道列表
   - 更新通信示例

4. **文件变更**（新增/重命名/移动）
   - 更新第12.2节（文件路径参考）
   - 更新文件行数统计

5. **架构变更**（新增模块/重构）
   - 更新第2章（整体分层架构）
   - 更新架构图
   - 更新层间通信机制

### 更新检查

在完成代码修改后，必须：
- [ ] 检查是否需要更新架构文档
- [ ] 使用文档中的更新检查清单（第13.3节）
- [ ] 更新"最后更新"日期
- [ ] 确保文档与代码一致
