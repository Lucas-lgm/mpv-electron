# Agent 工作流程（基于吴恩达设计模式）

> **版本**: 2.1.0  
> **最后更新**: 2026-01-27  
> **设计模式**: 基于 Andrew Ng 的 Agent 工作流设计模式

## 🎯 核心设计原则

基于吴恩达的 Agent 设计模式，本工作流包含以下核心组件：

1. **反思（Reflection）** - Agent 应该能够反思自己的输出，检查是否有错误或改进空间
2. **规划（Planning）** - 将复杂任务分解为可执行的子任务
3. **工具使用（Tool Use）** - 明确何时使用工具，如何选择最合适的工具
4. **执行（Action）** - 按照规划执行任务
5. **审查（Review）** - 审查执行结果，确保质量

## 📋 标准工作流程

### 阶段 1：需求理解（Understand & Reflect）

**目标**：深入理解用户需求，避免误解

**步骤**：
1. **仔细阅读用户需求**
   - 识别显式需求（用户明确说的）
   - 识别隐式需求（用户可能想要的）
   - 识别约束条件（技术限制、架构约束）

2. **理解业务目标和上下文**
   - 这个功能解决什么问题？
   - 与现有功能的关系是什么？
   - 用户的使用场景是什么？

3. **反思理解**
   - 我是否完全理解了需求？
   - 是否有模糊或不确定的地方？
   - 是否需要向用户澄清？

4. **识别相关文件和模块**
   - 使用 `codebase_search` 搜索相关代码
   - 使用 `grep` 查找特定模式
   - 识别可能受影响的模块

### 阶段 2：代码分析（Analyze & Plan）

**目标**：全面分析现有代码，制定详细计划

**步骤**：
1. **搜索现有实现（必须优先执行）**
   - 使用 `codebase_search` 搜索相似功能
   - 使用 `grep` 查找相关函数/类
   - **必须避免重复实现**
   - **识别可复用的代码模块**
   - **⚠️ 关键：如果要设计新接口/类型，必须先搜索现有调用方，了解实际数据格式**

2. **分析现有数据格式（设计接口前必须执行）**
   - **如果涉及 IPC 通信**：必须先用 `grep` 搜索 renderer 端如何发送数据
     - 例如：`grep "window.electronAPI.send.*channel-name"` 查看实际发送的数据格式
   - **如果涉及函数调用**：必须先用 `grep` 搜索现有调用方，了解实际参数格式
   - **如果涉及类型定义**：必须先检查现有类型定义，避免重复或冲突
   - **确保新设计的接口与现有调用方兼容**

3. **分析架构和依赖**
   - 识别需要修改的文件（main/preload/renderer/native）
   - 分析依赖关系和影响范围
   - 识别可能的风险点

4. **识别无用内容**
   - 查找未使用的代码
   - 识别过时的文档
   - 标记需要清理的内容

5. **工具选择**
   - 确定需要使用的工具（read_file, search_replace, write 等）
   - 确定搜索策略（codebase_search vs grep）
   - 确定是否需要网络访问或特殊权限

### 阶段 3：规划制定（Plan & Reflect）

**目标**：制定详细、可执行的实现计划

**必须包含以下内容**：

#### 1. 需求分析
- 用户目标是什么？
- 涉及哪些功能模块？
- 有哪些约束条件？

#### 2. 现有实现分析（⚠️ 必须包含）
- **现有数据格式**：renderer/main 端实际使用的数据格式是什么？
- **现有调用方式**：现有代码如何调用相关功能？
- **兼容性检查**：新设计是否与现有调用方兼容？
- **如果发现不兼容**：必须说明如何处理（修改调用方 vs 修改新设计）

#### 3. 影响范围
- 需要修改的文件清单（main/preload/renderer/native）
- 是否需要新增文件？
- 对现有功能的影响？
- 是否需要更新文档？

#### 4. 实现方案
- **数据流设计**：数据如何流动？必须与现有格式兼容
- **组件/模块设计**：如何组织代码？
- **IPC 通信设计**（如果涉及）：如何跨进程通信？**必须与现有 renderer 发送格式一致**
- **状态管理设计**：如何管理状态？

#### 5. 实现步骤（分解为子任务）
- 步骤 1：xxx（具体操作，使用的工具）
- 步骤 2：xxx（具体操作，使用的工具）
- ...（每个步骤应该清晰、可执行）
- **⚠️ 关键步骤**：验证新接口与现有调用方的兼容性

#### 6. 风险评估
- Electron 进程边界问题
- HDR/EDR 相关影响
- 性能考虑
- 内存管理
- **向后兼容性**：新设计是否破坏现有调用？
- **类型安全**：类型定义是否与实际数据格式一致？

#### 7. 测试方案
- 功能测试点
- 边界情况
- **兼容性测试**：确保现有功能不受影响
- 建议的测试命令

#### 8. 反思检查
- 计划是否完整？
- **是否已分析现有实现？**
- **新设计的接口是否与现有调用方兼容？**
- **类型定义是否与实际数据格式一致？**
- 是否考虑了所有边界情况？
- 是否有更好的实现方式？
- 是否需要用户澄清？

### 阶段 4：等待确认（Wait）

**目标**：确保用户理解并同意计划

**步骤**：
- 明确说明"等待确认"
- 不要直接修改代码
- 可以回答关于计划的提问
- 如果计划有问题，根据反馈调整

### 阶段 5：执行实现（Implement & Review）

**目标**：按照计划执行，并持续审查质量

**步骤**：

1. **执行子任务**
   - 严格按照计划实施
   - 每个步骤完成后检查结果
   - 如果遇到问题，暂停并重新规划

2. **工具使用**
   - 选择最合适的工具
   - 批量操作以提高效率
   - 确保工具调用正确

3. **代码质量检查**
   - 保持代码风格一致
   - 遵循现有模式
   - 确保类型安全

4. **实时审查**
   - 每完成一个文件，检查是否有错误
   - 使用 `read_lints` 检查语法错误
   - 确保代码符合架构设计

5. **文档更新**
   - **代码/架构变更完成后，当即更新 `docs/ARCHITECTURE.md`**
   - 更新相关注释
   - 不等待用户提醒

6. **最终审查**
   - 所有代码是否按计划实现？
   - 是否处理了所有边界情况？
   - 是否有遗漏的步骤？
   - 是否需要清理临时文件？

## 🔄 规划模板结构

每次规划必须包含：

### 1. 需求分析
- 用户目标是什么
- 涉及哪些功能模块
- 约束条件

### 2. 现有实现分析（⚠️ 必须包含）
- 现有数据格式：renderer/main 端实际使用的数据格式是什么？
- 现有调用方式：现有代码如何调用相关功能？
- 兼容性检查：新设计是否与现有调用方兼容？
- 如果发现不兼容：必须说明如何处理（修改调用方 vs 修改新设计）

### 3. 影响范围
- 需要修改的文件（main/preload/renderer/native）
- 是否需要新增文件
- 对现有功能的影响
- 是否需要更新文档？

### 4. 实现方案
- 数据流设计：必须与现有格式兼容
- 组件/模块设计
- IPC 通信设计（如果涉及）：必须与现有 renderer 发送格式一致
- 状态管理设计

### 5. 实现步骤（分解为子任务）
- 步骤 1：xxx（使用工具：xxx）
- 步骤 2：xxx（使用工具：xxx）
- ...
- ⚠️ 关键步骤：验证新接口与现有调用方的兼容性

### 6. 风险评估
- Electron 进程边界问题
- HDR/EDR 相关影响
- 性能考虑
- 内存管理
- 向后兼容性：新设计是否破坏现有调用？
- 类型安全：类型定义是否与实际数据格式一致？

### 7. 测试方案
- 功能测试点
- 边界情况
- 兼容性测试：确保现有功能不受影响
- 建议的测试命令

### 8. 反思检查
- 计划是否完整？
- 是否已分析现有实现？
- 新设计的接口是否与现有调用方兼容？
- 类型定义是否与实际数据格式一致？
- 是否考虑了所有边界情况？
- 是否有更好的实现方式？
- 是否需要用户澄清？

## 🛠️ 工具使用原则

### 何时使用 codebase_search
- 需要理解代码语义和上下文
- 查找相似功能的实现
- 理解架构和设计模式

### 何时使用 grep
- 查找精确的字符串匹配
- 查找函数/类/变量的引用
- 查找特定的模式

### 何时使用 read_file
- 需要查看完整文件内容
- 需要理解文件结构
- 准备编辑文件前

### 批量操作
- 多个相关操作应该批量执行
- 减少工具调用次数
- 提高效率

## 🔍 反思检查清单

在执行每个阶段后，都应该进行反思：

### 需求理解阶段
- [ ] 我是否完全理解了需求？
- [ ] 是否有模糊或不确定的地方？

### 代码分析阶段（⚠️ 关键）
- [ ] **是否搜索了现有实现？**
- [ ] **如果要设计新接口，是否先分析了现有调用方的数据格式？**
- [ ] **如果要设计 IPC 接口，是否先检查了 renderer 端如何发送数据？**
- [ ] **如果要设计类型，是否先检查了现有类型定义？**
- [ ] **新设计的接口是否与现有调用方兼容？**

### 规划制定阶段
- [ ] 计划是否完整和可执行？
- [ ] **是否包含了现有实现分析？**
- [ ] **是否说明了兼容性处理方案？**
- [ ] 是否选择了最合适的工具？

### 执行实现阶段
- [ ] 执行结果是否符合预期？
- [ ] **新接口是否与现有调用方兼容？**
- [ ] **类型定义是否与实际数据格式一致？**
- [ ] 是否有遗漏或错误？
- [ ] 是否需要调整计划？

## ⚠️ 常见错误避免

### 错误 1：先设计接口，后分析现有实现
**错误做法**：
1. 创建类型定义 `ControlSeekRequest { time: number }`
2. 实现 handler 期望 `{ time: number }`
3. 发现 renderer 发送的是 `number`，导致类型不匹配

**正确做法**：
1. 先用 `grep` 搜索 renderer 端：`grep "control-seek" src/renderer`
2. 确认实际发送格式：`window.electronAPI.send('control-seek', value)` - 直接发送数字
3. 再设计 handler：直接接收 `number`，而不是 `{ time: number }`

### 错误 2：假设数据格式，未验证
**错误做法**：
- 假设所有 IPC 消息都应该使用对象包装
- 创建统一的类型定义，强制所有消息使用对象

**正确做法**：
- 先搜索所有现有调用，了解实际格式
- 根据实际格式设计类型，而不是强制统一格式
- 保持与现有代码的兼容性

### 错误 3：忽略跨进程边界的数据格式
**错误做法**：
- 只关注 main 端的类型定义
- 忽略 renderer 端实际发送的数据格式

**正确做法**：
- **必须同时检查 renderer 和 main 端**
- 确保类型定义与实际 IPC 通信格式一致
- 使用 `grep` 搜索 `window.electronAPI.send` 和 `ipcMain.on` 确保匹配
